diff -up xf86-input-evdev-20120718/src/evdev.c.relscroll xf86-input-evdev-20120718/src/evdev.c
--- xf86-input-evdev-20120718/src/evdev.c.relscroll	2012-07-18 06:18:10.000000000 -0400
+++ xf86-input-evdev-20120718/src/evdev.c	2012-07-18 06:24:06.951594145 -0400
@@ -706,7 +706,9 @@ EvdevProcessRelativeMotionEvent(InputInf
 #endif
         default:
             /* Ignore EV_REL events if we never set up for them. */
-            if (!(pEvdev->flags & EVDEV_RELATIVE_EVENTS))
+            if (!(pEvdev->flags & EVDEV_RELATIVE_EVENTS) &&
+                    ev->code != REL_WHEEL && ev->code != REL_DIAL &&
+                    ev->code != REL_HWHEEL)
                 return;
 
             /* Handle mouse wheel emulation */
@@ -715,7 +717,7 @@ EvdevProcessRelativeMotionEvent(InputInf
 
             pEvdev->rel_queued = 1;
             pEvdev->delta[ev->code] += value;
-            map = pEvdev->axis_map[ev->code];
+            map = pEvdev->axis_map[ev->code + pEvdev->rel_offset];
             valuator_mask_set(pEvdev->vals, map, value);
             break;
     }
@@ -1239,7 +1241,7 @@ is_blacklisted_axis(int axis)
 
 
 static int
-EvdevAddAbsValuatorClass(DeviceIntPtr device)
+EvdevAddAbsValuatorClass(DeviceIntPtr device, int want_scroll_axes)
 {
     InputInfoPtr pInfo;
     EvdevPtr pEvdev;
@@ -1287,6 +1289,20 @@ EvdevAddAbsValuatorClass(DeviceIntPtr de
         }
     }
 #endif
+
+#ifdef HAVE_SMOOTH_SCROLLING
+    if (want_scroll_axes && EvdevBitIsSet(pEvdev->bitmask, EV_REL))
+    {
+        pEvdev->rel_offset = num_axes;
+        if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_WHEEL))
+            num_axes++;
+        if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_HWHEEL))
+            num_axes++;
+        if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_DIAL))
+            num_axes++;
+    }
+#endif
+
     if (num_axes + num_mt_axes > MAX_VALUATORS) {
         xf86IDrvMsg(pInfo, X_WARNING, "found %d axes, limiting to %d.\n", num_axes, MAX_VALUATORS);
         num_axes = MAX_VALUATORS;
@@ -1376,6 +1392,20 @@ EvdevAddAbsValuatorClass(DeviceIntPtr de
             i++;
     }
 
+#ifdef HAVE_SMOOTH_SCROLLING
+    if (want_scroll_axes)
+    {
+        int mapping = pEvdev->rel_offset;
+
+        if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_HWHEEL))
+            pEvdev->axis_map[pEvdev->rel_offset + REL_HWHEEL] = mapping++;
+        if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_DIAL))
+            pEvdev->axis_map[pEvdev->rel_offset + REL_DIAL] = mapping++;
+        if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_WHEEL))
+            pEvdev->axis_map[pEvdev->rel_offset + REL_WHEEL] = mapping++;
+    }
+#endif
+
     EvdevInitAxesLabels(pEvdev, Absolute, pEvdev->num_vals + num_mt_axes, atoms);
 
     if (!InitValuatorClassDeviceStruct(device, num_axes + num_mt_axes, atoms,
@@ -1470,6 +1500,51 @@ EvdevAddAbsValuatorClass(DeviceIntPtr de
     }
 #endif
 
+#ifdef HAVE_SMOOTH_SCROLLING
+    if (want_scroll_axes)
+    {
+        int axidx;
+        if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_WHEEL))
+        {
+            axidx = pEvdev->rel_offset + REL_WHEEL;
+            xf86InitValuatorAxisStruct(device,
+                                       pEvdev->axis_map[axidx],
+                                       atoms[pEvdev->axis_map[axidx]],
+                                       NO_AXIS_LIMITS, NO_AXIS_LIMITS,
+                                       0, 0, 0, Relative);
+            SetScrollValuator(device, pEvdev->axis_map[axidx],
+                              SCROLL_TYPE_VERTICAL, -1.0,
+                              SCROLL_FLAG_PREFERRED);
+        }
+
+        if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_HWHEEL))
+        {
+            axidx = pEvdev->rel_offset + REL_HWHEEL;
+            xf86InitValuatorAxisStruct(device,
+                                       pEvdev->axis_map[axidx],
+                                       atoms[pEvdev->axis_map[axidx]],
+                                       NO_AXIS_LIMITS, NO_AXIS_LIMITS,
+                                       0, 0, 0, Relative);
+            SetScrollValuator(device, pEvdev->axis_map[axidx],
+                              SCROLL_TYPE_HORIZONTAL, 1.0,
+                              SCROLL_FLAG_NONE);
+        }
+
+        if (EvdevBitIsSet(pEvdev->rel_bitmask, REL_DIAL))
+        {
+            axidx = pEvdev->rel_offset + REL_DIAL;
+            xf86InitValuatorAxisStruct(device,
+                                       pEvdev->axis_map[axidx],
+                                       atoms[pEvdev->axis_map[axidx]],
+                                       NO_AXIS_LIMITS, NO_AXIS_LIMITS,
+                                       0, 0, 0, Relative);
+            SetScrollValuator(device, pEvdev->axis_map[axidx],
+                              SCROLL_TYPE_HORIZONTAL, 1.0,
+                              SCROLL_FLAG_NONE);
+        }
+    }
+#endif
+
     free(atoms);
 
     for (i = 0; i < ArrayLength(proximity_bits); i++)
@@ -1699,12 +1774,16 @@ static void
 EvdevInitAnyValuators(DeviceIntPtr device, EvdevPtr pEvdev)
 {
     InputInfoPtr pInfo = device->public.devicePrivate;
+    int rel_success = FALSE;
 
     if (pEvdev->flags & EVDEV_RELATIVE_EVENTS &&
         EvdevAddRelValuatorClass(device) == Success)
+    {
+        rel_success = TRUE;
         xf86IDrvMsg(pInfo, X_INFO, "initialized for relative axes.\n");
+    }
     if (pEvdev->flags & EVDEV_ABSOLUTE_EVENTS &&
-        EvdevAddAbsValuatorClass(device) == Success)
+        EvdevAddAbsValuatorClass(device, !rel_success) == Success)
         xf86IDrvMsg(pInfo, X_INFO, "initialized for absolute axes.\n");
 }
 
@@ -1713,7 +1792,7 @@ EvdevInitAbsValuators(DeviceIntPtr devic
 {
     InputInfoPtr pInfo = device->public.devicePrivate;
 
-    if (EvdevAddAbsValuatorClass(device) == Success) {
+    if (EvdevAddAbsValuatorClass(device, TRUE) == Success) {
         xf86IDrvMsg(pInfo, X_INFO,"initialized for absolute axes.\n");
     } else {
         xf86IDrvMsg(pInfo, X_ERROR,"failed to initialize for absolute axes.\n");
diff -up xf86-input-evdev-20120718/src/evdev.h.relscroll xf86-input-evdev-20120718/src/evdev.h
--- xf86-input-evdev-20120718/src/evdev.h.relscroll	2012-07-18 06:18:10.000000000 -0400
+++ xf86-input-evdev-20120718/src/evdev.h	2012-07-18 06:24:32.542274216 -0400
@@ -154,7 +154,8 @@ typedef struct {
 
     int num_vals;           /* number of valuators */
     int num_mt_vals;        /* number of multitouch valuators */
-    int axis_map[max(ABS_CNT, REL_CNT)]; /* Map evdev <axis> to index */
+    int axis_map[ABS_CNT + REL_CNT]; /* Map evdev <axis> to index */
+    int rel_offset;         /* offset for relative axes in absolute device */
     ValuatorMask *vals;     /* new values coming in */
     ValuatorMask *old_vals; /* old values for calculating relative motion */
     ValuatorMask *prox;     /* last values set while not in proximity */
