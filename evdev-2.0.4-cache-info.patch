From 441a97c22933db462dd53e000d1cb269dab6e825 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@redhat.com>
Date: Thu, 28 Aug 2008 10:29:26 +0930
Subject: [PATCH] Cache device information and compare against info after re-open.

This way we ensure that if the topology changes under us, we don't open a
completely different device. If a device has changed, we disable it.
(cherry picked from commit 3bb7d100570134058eb4c906d4902c655148a8be)

Conflicts:

	src/evdev.c
	src/evdev.h
---
 src/evdev.c |  131 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 src/evdev.h |   12 +++++
 2 files changed, 137 insertions(+), 6 deletions(-)

diff --git a/src/evdev.c b/src/evdev.c
index 16cf67f..ca6da6e 100644
--- a/src/evdev.c
+++ b/src/evdev.c
@@ -98,6 +98,7 @@ static const char *evdevDefaults[] = {
 };
 
 static int EvdevOn(DeviceIntPtr);
+static int EvdevCacheCompare(InputInfoPtr pInfo, Bool compare);
 
 static void
 SetXkbOption(InputInfoPtr pInfo, char *name, char **option)
@@ -176,11 +177,19 @@ EvdevReopenTimer(OsTimerPtr timer, CARD32 time, pointer arg)
 
     if (pInfo->fd != -1)
     {
-        xf86Msg(X_INFO, "%s: Device reopened after %d attempts.\n", pInfo->name,
-                pEvdev->reopen_attempts - pEvdev->reopen_left);
-
         pEvdev->reopen_left = 0;
-        EvdevOn(pInfo->dev);
+
+        if (EvdevCacheCompare(pInfo, TRUE) == Success)
+        {
+            xf86Msg(X_INFO, "%s: Device reopened after %d attempts.\n", pInfo->name,
+                    pEvdev->reopen_attempts - pEvdev->reopen_left);
+            EvdevOn(pInfo->dev);
+        } else
+        {
+            xf86Msg(X_ERROR, "%s: Device has changed - disabling.\n",
+                    pInfo->name);
+            DisableDevice(pInfo->dev);
+        }
         return 0;
     }
 
@@ -368,8 +377,6 @@ EvdevReadInput(InputInfoPtr pInfo)
     }
 }
 
-#define LONG_BITS (sizeof(long) * 8)
-#define NBITS(x) (((x) + LONG_BITS - 1) / LONG_BITS)
 #define TestBit(bit, array) (array[(bit) / LONG_BITS]) & (1 << ((bit) % LONG_BITS))
 
 static void
@@ -994,6 +1001,116 @@ EvdevConvert(InputInfoPtr pInfo, int first, int num, int v0, int v1, int v2,
     return TRUE;
 }
 
+/**
+ * Get as much information as we can from the fd and cache it.
+ * If compare is True, then the information retrieved will be compared to the
+ * one already cached. If the information does not match, then this function
+ * returns an error.
+ *
+ * @return Success if the information was cached, or !Success otherwise.
+ */
+static int
+EvdevCacheCompare(InputInfoPtr pInfo, Bool compare)
+{
+    int i;
+    EvdevPtr pEvdev = pInfo->private;
+    char name[1024]                  = {0};
+    long bitmask[NBITS(EV_MAX)]      = {0};
+    long key_bitmask[NBITS(KEY_MAX)] = {0};
+    long rel_bitmask[NBITS(REL_MAX)] = {0};
+    long abs_bitmask[NBITS(ABS_MAX)] = {0};
+    long led_bitmask[NBITS(LED_MAX)] = {0};
+    struct input_absinfo absinfo[ABS_MAX];
+
+    if (ioctl(pInfo->fd,
+              EVIOCGNAME(sizeof(name) - 1), name) < 0) {
+        xf86Msg(X_ERROR, "ioctl EVIOCGNAME failed: %s\n", strerror(errno));
+        goto error;
+    }
+
+    if (compare && strcmp(pEvdev->name, name))
+        goto error;
+
+    if (ioctl(pInfo->fd,
+              EVIOCGBIT(0, sizeof(bitmask)), bitmask) < 0) {
+        xf86Msg(X_ERROR, "ioctl EVIOCGNAME failed: %s\n", strerror(errno));
+        goto error;
+    }
+
+    if (compare && memcmp(pEvdev->bitmask, bitmask, sizeof(bitmask)))
+        goto error;
+
+
+    if (ioctl(pInfo->fd,
+              EVIOCGBIT(EV_REL, sizeof(rel_bitmask)), rel_bitmask) < 0) {
+        xf86Msg(X_ERROR, "ioctl EVIOCGBIT failed: %s\n", strerror(errno));
+        goto error;
+    }
+
+    if (compare && memcmp(pEvdev->rel_bitmask, rel_bitmask, sizeof(rel_bitmask)))
+        goto error;
+
+    if (ioctl(pInfo->fd,
+              EVIOCGBIT(EV_ABS, sizeof(abs_bitmask)), abs_bitmask) < 0) {
+        xf86Msg(X_ERROR, "ioctl EVIOCGBIT failed: %s\n", strerror(errno));
+        goto error;
+    }
+
+    if (compare && memcmp(pEvdev->abs_bitmask, abs_bitmask, sizeof(abs_bitmask)))
+        goto error;
+
+    if (ioctl(pInfo->fd,
+              EVIOCGBIT(EV_KEY, sizeof(key_bitmask)), key_bitmask) < 0) {
+        xf86Msg(X_ERROR, "ioctl EVIOCGBIT failed: %s\n", strerror(errno));
+        goto error;
+    }
+
+    if (compare && memcmp(pEvdev->key_bitmask, key_bitmask, sizeof(key_bitmask)))
+        goto error;
+
+    if (ioctl(pInfo->fd,
+              EVIOCGBIT(EV_LED, sizeof(led_bitmask)), led_bitmask) < 0) {
+        xf86Msg(X_ERROR, "ioctl EVIOCGBIT failed: %s\n", strerror(errno));
+        goto error;
+    }
+
+    if (compare && memcmp(pEvdev->led_bitmask, led_bitmask, sizeof(led_bitmask)))
+        goto error;
+
+    memset(absinfo, 0, sizeof(absinfo));
+
+    for (i = 0; i < ABS_MAX; i++)
+    {
+        if (TestBit(i, abs_bitmask))
+        {
+            if (ioctl(pInfo->fd, EVIOCGABS(i), &absinfo[i]) < 0) {
+                xf86Msg(X_ERROR, "ioctl EVIOCGABS failed: %s\n", strerror(errno));
+                goto error;
+            }
+        }
+    }
+
+    if (compare && memcmp(pEvdev->absinfo, absinfo, sizeof(absinfo)))
+            goto error;
+
+    /* cache info */
+    if (!compare)
+    {
+        strcpy(pEvdev->name, name);
+        memcpy(pEvdev->bitmask, bitmask, sizeof(bitmask));
+        memcpy(pEvdev->key_bitmask, key_bitmask, sizeof(key_bitmask));
+        memcpy(pEvdev->rel_bitmask, rel_bitmask, sizeof(rel_bitmask));
+        memcpy(pEvdev->abs_bitmask, abs_bitmask, sizeof(abs_bitmask));
+        memcpy(pEvdev->led_bitmask, led_bitmask, sizeof(led_bitmask));
+        memcpy(pEvdev->absinfo, absinfo, sizeof(absinfo));
+    }
+
+    return Success;
+
+error:
+    return !Success;
+}
+
 static int
 EvdevProbe(InputInfoPtr pInfo)
 {
@@ -1173,6 +1290,8 @@ EvdevPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
         return NULL;
     }
 
+    EvdevCacheCompare(pInfo, FALSE); /* cache device data */
+
     return pInfo;
 }
 
diff --git a/src/evdev.h b/src/evdev.h
index 0f8cf4b..47bbff2 100644
--- a/src/evdev.h
+++ b/src/evdev.h
@@ -40,6 +40,9 @@
 #include <X11/extensions/XKBstr.h>
 #endif
 
+#define LONG_BITS (sizeof(long) * 8)
+#define NBITS(x) (((x) + LONG_BITS - 1) / LONG_BITS)
+
 typedef struct {
     const char *device;
     int kernel24;
@@ -71,6 +74,15 @@ typedef struct {
 
     int reopen_attempts; /* max attempts to re-open after read failure */
     int reopen_left;     /* number of attempts left to re-open the device */
+
+    /* Cached info from device. */
+    char name[1024];
+    long bitmask[NBITS(EV_MAX)];
+    long key_bitmask[NBITS(KEY_MAX)];
+    long rel_bitmask[NBITS(REL_MAX)];
+    long abs_bitmask[NBITS(ABS_MAX)];
+    long led_bitmask[NBITS(LED_MAX)];
+    struct input_absinfo absinfo[ABS_MAX];
 } EvdevRec, *EvdevPtr;
 
 /* Middle Button emulation */
-- 
1.5.6.4

